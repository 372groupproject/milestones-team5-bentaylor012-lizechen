#Purpose: This program is to compute the shortest 
#         distance between two cities via Dijkstra algorithm
#

$include "processData.ico"
$include "dijkstra.ico"

global head

procedure main()
    local filename, lines, line
    write("**Please input the filename:")
    repeat{
        filename := read()
        if (lines := open(filename, "rw")) then break
        else write("**The input is invalid. Please try 'graph.txt'.")
    } 
    createLinkedlist(lines)
    close(lines)
    write("**Require two cities separated by space in lowercase:")
    write("**You can terminate the program by inputting -1")
    repeat{
        line := read()
        if numeric(line) = -1 then exit()
        readLine(line)
    }
end


# Purpose: read the input line, and check if it is valid
#          if it is valid, pass it into dijkstra algorithm
#
procedure readLine(line)
    local wordlist, ptr, flag1, flag2, name1, name2, ptr1, ptr2, val
    val := 0
    wordlist := []
    line ? { 
        while tab(upto(&letters ++ &digits)) do
            put(wordlist, tab(many(&letters ++ &digits)))
    }
    if (*wordlist ~= 2) then write("Illegal query.") & return
    name1 := wordlist[1]
    name2 := wordlist[2]
    flag1 := 0
    flag2 := 0
    ptr := head
    while (ptr ~=== &null) do {
        if (ptr.name == name1) then flag1 := 1 & ptr1 := ptr
        if (ptr.name == name2) then flag2 := 1 & ptr2 := ptr
        ptr := ptr.next1
    }
    if (flag1 = 0) then write ("No node named ", name1) & return
    if (flag2 = 0) then write ("No node named ", name2) & return
    if (name1 ~== name2) then val := dijkstra(ptr1,ptr2)
    write(val)    
end


# Purpose: create a linkedlist based on the input lines
#
procedure createLinkedlist(fileName)
    local line
    while line := read(fileName) do {
        head := process(line)
    }
end


# Purpose: used to test the output of the linkedlist
#
procedure output()
    local ptr
    ptr := head
    if (ptr === &null) then write("it is null")
    while ptr ~=== &null do{
        write(ptr.name)
        ptr := ptr.next1
    }
end


